##EJERCICIO 1 y 2
// --------------------------------------
// i2c_scanner
//
// Modified from https://playground.arduino.cc/Main/I2cScanner/
// --------------------------------------

#include <Wire.h>

// Set I2C bus to use: Wire, Wire1, etc.
//#define WIRE Wire
#define I2C_SDA 21
#define I2C_SCL 20


void setup() {
    Wire.begin(I2C_SDA, I2C_SCL);

  //Serial.begin(9600);
  Serial.begin(115200);

  while (!Serial)
     delay(10);
  Serial.println("\nI2C Scanner");
}


void loop() {
  byte error, address;
  int nDevices;

  Serial.println("Scanning...");

  nDevices = 0;
  for(address = 1; address < 127; address++ ) 
  {
    // The i2c_scanner uses the return value of
    // the Write.endTransmisstion to see if
    // a device did acknowledge to the address.
    Wire.beginTransmission(address);
    error = Wire.endTransmission();

    if (error == 0)
    {
      Serial.print("I2C device found at address 0x");
      if (address<16) 
        Serial.print("0");
      Serial.print(address,HEX);
      Serial.println("  !");

      nDevices++;
    }
    else if (error==4) 
    {
      Serial.print("Unknown error at address 0x");
      if (address<16) 
        Serial.print("0");
      Serial.println(address,HEX);
    }    
  }
  if (nDevices == 0)
    Serial.println("No I2C devices found\n");
  else
    Serial.println("done\n");

  delay(3000);           // wait 5 seconds for next scan
}
##EJERCICIO 3

#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BME280.h>

#define I2C_SDA 21
#define I2C_SCL 20
#define LED_VERDE 2          // Pin del LED verde
#define SEALEVELPRESSURE_HPA (1013.25)

Adafruit_BME280 bme;          // Objeto del sensor

void setup() {
  Serial.begin(115200);
  while (!Serial) delay(10);

  pinMode(LED_VERDE, OUTPUT);
  digitalWrite(LED_VERDE, LOW);

  Serial.println("Inicializando BME280...");

  // Inicializar bus I2C con los pines usados en los ejercicios previos
  Wire.begin(I2C_SDA, I2C_SCL);

  // Intentar detectar el sensor (direcci√≥n 0x76 o 0x77)
  if (!bme.begin(0x76)) {
    Serial.println("‚ùå No se encontr√≥ el BME280 en 0x76. Probando 0x77...");
    if (!bme.begin(0x77)) {
      Serial.println("‚ùå No se encontr√≥ ning√∫n BME280. Verifica el cableado.");
      while (1) delay(10);
    }
  }

  Serial.println("‚úÖ BME280 inicializado correctamente.\n");
}

void loop() {
  // Encender LED cuando se realiza la medida
  digitalWrite(LED_VERDE, HIGH);

  // Lectura de datos
  float temperatura = bme.readTemperature();     // ¬∞C
  float presion = bme.readPressure() / 100.0F;   // hPa
  float humedad = bme.readHumidity();            // %

  // Mostrar por monitor serial
  Serial.println("------ Nueva medida ------");
  Serial.print("Temperatura: "); Serial.print(temperatura); Serial.println(" ¬∞C");
  Serial.print("Presi√≥n:     "); Serial.print(presion); Serial.println(" hPa");
  Serial.print("Humedad:     "); Serial.print(humedad); Serial.println(" %");
  Serial.println("--------------------------\n");

  // Mantener LED encendido 1 s
  delay(1000);
  digitalWrite(LED_VERDE, LOW);

  // Esperar hasta completar los 5 s totales entre mediciones
  delay(4000);
}

##EJERCICIO 4A Y B
#EJ 4A
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BME280.h>

// Pines de conexi√≥n I¬≤C
#define I2C_SDA 21
#define I2C_SCL 20

// LED grande del ESP32-S3 DevKitC-1
#define LED_VERDE 48

#define SEALEVELPRESSURE_HPA (1013.25)

Adafruit_BME280 bme;

// Intervalos de tiempo
const float intervalo_lectura = 0.1;   // segundos
const float intervalo_media = 5.0;     // segundos
const int num_muestras = intervalo_media / intervalo_lectura; // 50 lecturas

// Variables acumuladoras
float suma_temp = 0;
float suma_hum = 0;
float suma_pres = 0;
int contador = 0;

// Temporizadores
unsigned long t_ultimo = 0;
unsigned long t_led = 0;

void setup() {
  Serial.begin(115200);
  while (!Serial) delay(10);

  pinMode(LED_VERDE, OUTPUT);
  digitalWrite(LED_VERDE, LOW);

  // Inicializar bus I¬≤C
  Wire.begin(I2C_SDA, I2C_SCL);

  Serial.println("Inicializando BME280...");

  // Direcci√≥n fija 0x76 (c√°mbiala a 0x77 si tu esc√°ner lo indic√≥)
  if (!bme.begin(0x76)) {
    Serial.println("‚ùå No se encontr√≥ el BME280 en 0x76. Verifica el cableado o la direcci√≥n.");
    while (1) delay(10);
  }

  Serial.println("‚úÖ BME280 inicializado correctamente.");
  Serial.println("Midiendo cada 0.1 s y mostrando media cada 5 s...\n");
}

void loop() {
  unsigned long ahora = millis();

  // Parpadeo LED cada 100 ms
  if (ahora - t_led >= 100) {
    digitalWrite(LED_VERDE, !digitalRead(LED_VERDE));
    t_led = ahora;
  }

  // Lectura del sensor cada 100 ms
  if (ahora - t_ultimo >= 100) {
    t_ultimo = ahora;

    float t = bme.readTemperature();
    float h = bme.readHumidity();
    float p = bme.readPressure() / 100.0F;

    suma_temp += t;
    suma_hum += h;
    suma_pres += p;
    contador++;

    // Cada 5 s (50 lecturas)
    if (contador >= num_muestras) {
      float media_t = suma_temp / contador;
      float media_h = suma_hum / contador;
      float media_p = suma_pres / contador;

      Serial.print("Media (√∫ltimos 5 s) ‚Üí ");
      Serial.print("Temp: "); Serial.print(media_t, 2); Serial.print(" ¬∞C, ");
      Serial.print("Hum: "); Serial.print(media_h, 2); Serial.print(" %, ");
      Serial.print("Pres: "); Serial.print(media_p, 2); Serial.println(" hPa");

      suma_temp = suma_hum = suma_pres = 0;
      contador = 0;
    }
  }
}

#4B
import serial
import time
import re
import matplotlib.pyplot as plt

# Ajusta el puerto a tu caso (ej. "COM5" en Windows o "/dev/ttyUSB0" en Linux/Mac)
puerto = "COM3"
baudrate = 115200

# Expresi√≥n regular para extraer los n√∫meros
patron = re.compile(r"Temp:\s*([\d\.\-]+).*Hum:\s*([\d\.\-]+).*Pres:\s*([\d\.\-]+)")

temps, hums, press, tiempos = [], [], [], []
inicio = time.time()

ser = serial.Serial(puerto, baudrate, timeout=1)
print("Leyendo datos del ESP32-S3...\n")

try:
    while True:
        linea = ser.readline().decode(errors='ignore').strip()
        if linea:
            print(linea)
            m = patron.search(linea)
            if m:
                temps.append(float(m.group(1)))
                hums.append(float(m.group(2)))
                press.append(float(m.group(3)))
                tiempos.append(time.time() - inicio)

                # Mostrar gr√°fica en tiempo real cada 5 muestras
                if len(temps) % 5 == 0:
                    plt.clf()
                    plt.subplot(3, 1, 1)
                    plt.plot(tiempos, temps, 'r-')
                    plt.ylabel("¬∞C")
                    plt.subplot(3, 1, 2)
                    plt.plot(tiempos, hums, 'b-')
                    plt.ylabel("%")
                    plt.subplot(3, 1, 3)
                    plt.plot(tiempos, press, 'g-')
                    plt.ylabel("hPa")
                    plt.xlabel("Tiempo (s)")
                    plt.pause(0.01)
except KeyboardInterrupt:
    print("Finalizado por el usuario.")
finally:
    ser.close()
    plt.show()

## EJERCICIO 5 (NUEVOS EJERCICIOS 2 CLIENTE SERVIDOR)

#Parte cliente
#include <WiFi.h>

const char* ssid = "ServidorESP";
const char* password = "12345678";

const char* host = "192.168.4.1";  // IP del servidor AP
const uint16_t port = 80;

void setup() {
  Serial.begin(115200);
  Serial.println("Conectando al servidor AP...");

  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(500);
  }

  Serial.println("\n‚úÖ Conectado al AP del servidor!");
  Serial.print("IP del cliente: ");
  Serial.println(WiFi.localIP());
}

void loop() {
  WiFiClient client;

  Serial.print("Conectando al servidor ");
  Serial.println(host);

  if (!client.connect(host, port)) {
    Serial.println("‚ùå Error al conectar con el servidor.");
    delay(3000);
    return;
  }

  Serial.println("‚úÖ Conectado, enviando mensaje...");
  client.println("Hola desde el cliente ESP32!");
  
  // Esperar respuesta
  while (client.connected() && !client.available()) {
    delay(10);
  }

  if (client.available()) {
    String respuesta = client.readStringUntil('\n');
    Serial.print("üì® Respuesta del servidor: ");
    Serial.println(respuesta);
  }

  client.stop();
  Serial.println("üîö Conexi√≥n cerrada.\n");
  delay(5000);
}

#Parte servidor

#include <WiFi.h>

WiFiServer server(80);

void setup() {
  Serial.begin(115200);

  // Crea red WiFi propia del ESP32
  WiFi.softAP("ServidorESP", "12345678");

  IPAddress IP = WiFi.softAPIP();
  Serial.print("üåê Punto de acceso creado. IP del servidor: ");
  Serial.println(IP);  // -> deber√≠a mostrar 192.168.4.1

  server.begin();
  Serial.println("Servidor listo, esperando clientes...");
}

void loop() {
  WiFiClient client = server.available();  // Espera cliente

  if (client) {
    Serial.println("üü¢ Cliente conectado!");

    while (client.connected()) {
      if (client.available()) {
        String line = client.readStringUntil('\n');
        Serial.print("üì© Mensaje del cliente: ");
        Serial.println(line);
        client.println("Mensaje recibido por el servidor ESP32!");
      }
    }

    client.stop();
    Serial.println("üî¥ Cliente desconectado.\n");
  }
}

## EJERCICIO 3 CONECTARSE A EDUROAM

/*|----------------------------------------------------------|*/
/*|Connection sketch to eduroam network (WPA/WPA2) Enteprise |*/
/*|Suitable for almost any ESP32 microcontroller with WiFi   |*/
/*|Raspberry or Arduino WiFi CAN'T USE THIS LIBRARY!!!       |*/
/*|Edited by: Martin Chlebovec (martinius96)                 |*/
/*|Compilation under 2.0.3 Arduino Core and higher worked    |*/
/*|Compilation can be done only using STABLE releases        |*/
/*|Dev releases WILL NOT WORK. (Check your Ard. Core .json)  |*/
/*|WiFi.begin() have more parameters for PEAP connection     |*/
/*|----------------------------------------------------------|*/

//WITHOUT certificate option connection is WORKING (if there is exception set on RADIUS server that will let connect devices without certificate)
//It is DEPRECATED function and standardly turned off, so it must be turned on by your eduroam management at university / organisation

//Connection with certificate WASN'T CONFIRMED ever, so probably that option is NOT WORKING

#include <WiFi.h> //Wifi library
#include "esp_eap_client.h" //"esp_wpa2.h" //wpa2 library for connections to Enterprise networks

//Identity for user with password related to his realm (organization)
//Available option of anonymous identity for federation of RADIUS servers or 1st Domain RADIUS servers
#define EAP_ANONYMOUS_IDENTITY "UO297006@uniovi.es" //anonymous@example.com, or you can use also nickname@example.com
#define EAP_IDENTITY "UO297006@uniovi.es" //nickname@example.com, at some organizations should work nickname only without realm, but it is not recommended
#define EAP_PASSWORD "160404Kmb%" //password for eduroam account
#define EAP_USERNAME "UO297006@uniovi.es" // the Username is the same as the Identity in most eduroam networks.

//SSID NAME
const char* ssid = "eduroam"; // eduroam SSID


void setup() {
  Serial.begin(115200);
  delay(10);
  Serial.print(F("Connecting to network: "));
  Serial.println(ssid);
  WiFi.disconnect(true);  //disconnect from WiFi to set new WiFi connection
  //WiFi.begin(ssid, WPA2_AUTH_PEAP, EAP_ANONYMOUS_IDENTITY, EAP_IDENTITY, EAP_PASSWORD, test_root_ca); //with CERTIFICATE 
  WiFi.begin(ssid, WPA2_AUTH_PEAP, EAP_IDENTITY, EAP_USERNAME, EAP_PASSWORD); // without CERTIFICATE, RADIUS server EXCEPTION "for old devices" required

  // Example: a cert-file WPA2 Enterprise with PEAP - client certificate and client key required
  //WiFi.begin(ssid, WPA2_AUTH_PEAP, EAP_IDENTITY, EAP_USERNAME, EAP_PASSWORD, test_root_ca, client_cert, client_key);

  // Example: TLS with cert-files and no password - client certificate and client key required
  //WiFi.begin(ssid, WPA2_AUTH_TLS, EAP_IDENTITY, NULL, NULL, test_root_ca, client_cert, client_key);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(F("."));
  }
  Serial.println("");
  Serial.println(F("WiFi is connected!"));
  Serial.println(F("IP address set: "));
  Serial.println(WiFi.localIP()); //print LAN IP
}

void loop() {
  yield();
}

