#include <Wire.h>
#include <Adafruit_LTR390.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BME280.h>

// ===========================
// CONFIGURACI√ìN DE PINES
// ===========================
// LTR390 (sensor UV)
#define UV_SDA 21
#define UV_SCL 20

// BME280 (temperatura, humedad, presi√≥n)
#define BME_SDA 45
#define BME_SCL 0

#define RGB_BRIGHTNESS 50   // brillo m√°ximo del LED RGB integrado
#define LED_VERDE 2         // LED externo opcional (puede omitirse)

// ===========================
// OBJETOS DE SENSORES
// ===========================
Adafruit_LTR390 ltr = Adafruit_LTR390();
Adafruit_BME280 bme;
TwoWire WireUV = TwoWire(0);
TwoWire WireBME = TwoWire(1);

// ===========================
// PAR√ÅMETROS DE CALIBRACI√ìN Y UMBRALES
// ===========================
#define FACTOR_CALIBRACION 2300.0

// --- Umbrales UV ---
const float WARNING_UVI  = 3.0;
const float ALERT_UVI    = 6.0;
const float CRITICAL_UVI = 8.0;

// --- Umbrales ambientales ---
const float TEMP_MAX = 35.0;   // ¬∞C
const float TEMP_MIN = 0.0;
const float HUM_MAX = 85.0;    // % 
const float HUM_MIN = 20.0;
const float PRES_MIN = 980.0;  // hPa
const float PRES_MAX = 1030.0;

// Intervalo de muestreo
const unsigned long MEASURE_INTERVAL_MS = 5000;
unsigned long lastMillis = 0;

// ===========================
// FUNCIONES AUXILIARES
// ===========================
void setRGB(uint8_t r, uint8_t g, uint8_t b) {
  rgbLedWrite(RGB_BUILTIN, r, g, b);
}

void blinkRGB(uint8_t r, uint8_t g, uint8_t b, int times, int msDelay) {
  for (int i = 0; i < times; i++) {
    setRGB(r, g, b);
    delay(msDelay);
    setRGB(0, 0, 0);
    delay(msDelay);
  }
}

// ===========================
// CONFIGURACI√ìN
// ===========================
void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("\nüåç Inicializando sensores en buses I2C separados...");

  // ---- Iniciar bus del LTR390 ----
  WireUV.begin(UV_SDA, UV_SCL);
  if (!ltr.begin(&WireUV)) {
    Serial.println("‚ùå No se detect√≥ LTR390. Revisa conexiones (SDA=21, SCL=20).");
  } else {
    Serial.println("‚úÖ LTR390 detectado (bus UV).");
    ltr.setMode(LTR390_MODE_UVS);
    ltr.setGain(LTR390_GAIN_18);
    ltr.setResolution(LTR390_RESOLUTION_20BIT);
  }

  // ---- Iniciar bus del BME280 ----
  WireBME.begin(BME_SDA, BME_SCL);
  if (!bme.begin(0x76, &WireBME)) {
    Serial.println("‚ùå No se encontr√≥ BME280 en 0x76. Probando 0x77...");
    if (!bme.begin(0x77, &WireBME)) {
      Serial.println("‚ùå No se encontr√≥ ning√∫n BME280 (SDA=45, SCL=0). Verifica el cableado.");
      while (1) delay(10);
    }
  }
  Serial.println("‚úÖ BME280 inicializado correctamente (bus ambiental).\n");

  // LED externo (opcional)
  pinMode(LED_VERDE, OUTPUT);
  digitalWrite(LED_VERDE, LOW);

  setRGB(0, 0, 0);
}

// ===========================
// BUCLE PRINCIPAL
// ===========================
void loop() {
  unsigned long now = millis();
  if (now - lastMillis < MEASURE_INTERVAL_MS) return;
  lastMillis = now;

  Serial.println("üìä ===== Nueva lectura =====");

  // ====================
  // SENSOR UV (LTR390)
  // ====================
  if (ltr.newDataAvailable()) {
    uint32_t uvs = ltr.readUVS();
    float uvi = uvs / FACTOR_CALIBRACION;

    Serial.print("‚òÄÔ∏è  UVI estimado: ");
    Serial.println(uvi, 2);

    // Alarmas UV
    if (uvi >= CRITICAL_UVI) {
      Serial.println("‚ö†Ô∏è CR√çTICO: UVI extremo");
      blinkRGB(RGB_BRIGHTNESS, 0, 0, 6, 150);
    } else if (uvi >= ALERT_UVI) {
      Serial.println("‚ö†Ô∏è ALERTA: UVI alto");
      blinkRGB(RGB_BRIGHTNESS, RGB_BRIGHTNESS / 2, 0, 4, 300);
    } else if (uvi >= WARNING_UVI) {
      Serial.println("‚ö†Ô∏è ADVERTENCIA: UVI moderado");
      blinkRGB(RGB_BRIGHTNESS, RGB_BRIGHTNESS, 0, 3, 400);
    } else {
      Serial.println("‚úÖ UVI bajo (normal)");
      setRGB(0, RGB_BRIGHTNESS, 0);
      delay(1000);
      setRGB(0, 0, 0);
    }
  } else {
    Serial.println("‚ö†Ô∏è Sin nuevos datos UV.");
  }

  // ====================
  // SENSOR BME280
  // ====================
  digitalWrite(LED_VERDE, HIGH);

  float temp = bme.readTemperature();
  float pres = bme.readPressure() / 100.0F;
  float hum  = bme.readHumidity();

  Serial.print("üå°Ô∏è  Temp: ");
  Serial.print(temp);
  Serial.print(" ¬∞C | üíß Humedad: ");
  Serial.print(hum);
  Serial.print(" % | ‚õÖ Presi√≥n: ");
  Serial.print(pres);
  Serial.println(" hPa");

  bool alerta = false;
  
  // Evaluar estado de humedad
  if (hum < HUM_MIN || hum > HUM_MAX) {
    alerta = true;
    Serial.println("‚ö†Ô∏è Humedad fuera de rango!");
  }
  // Evaluar estado de temperatura
  if (temp < TEMP_MIN || temp > TEMP_MAX) {
    alerta = true;
    Serial.println("‚ö†Ô∏è Temperatura fuera de rango!");
  }
  // Evaluar estado de presi√≥n
  if (pres < PRES_MIN || pres > PRES_MAX) {
    alerta = true;
    Serial.println("‚ö†Ô∏è Presi√≥n fuera de rango!");
  }

  // Control de LED de estado
  if (hum >= HUM_MIN && hum <= HUM_MAX && temp >= TEMP_MIN && temp <= TEMP_MAX && pres >= PRES_MIN && pres <= PRES_MAX) {
    // Dentro de rango normal
    setRGB(0, RGB_BRIGHTNESS, 0); // Verde
  } else if (hum >= HUM_MIN * 0.8 && hum <= HUM_MAX * 1.2 && temp >= TEMP_MIN * 0.8 && temp <= TEMP_MAX * 1.2 && pres >= PRES_MIN * 0.8 && pres <= PRES_MAX * 1.2) {
    // Lejos del rango pero no extremo
    setRGB(RGB_BRIGHTNESS, RGB_BRIGHTNESS / 2, 0); // Naranja
  } else {
    // Valor extremo, parpadeo en rojo
    blinkRGB(RGB_BRIGHTNESS, 0, 0, 5, 300); // Rojo parpadeante
  }

  digitalWrite(LED_VERDE, LOW);
  Serial.println("=============================\n");
}